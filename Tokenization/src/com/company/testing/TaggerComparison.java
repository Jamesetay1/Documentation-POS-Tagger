package com.company.testing;

import com.company.Tokenizer;
import edu.stanford.nlp.pipeline.CoreDocument;
import edu.stanford.nlp.pipeline.CoreSentence;
import edu.stanford.nlp.pipeline.StanfordCoreNLP;


import java.util.Collection;
import java.util.Properties;
import java.util.stream.Collectors;

public class TaggerComparison {
	private static String TEST_STRING = "The class wraps a value of the primitive type in an object . An object of type contains a single field whose type is . In addition , this class provides several methods for converting a to a and a to a , as well as other constants and methods useful when dealing with a . Returns a string representation of the argument . All characters mentioned below are ASCII characters . If the argument is NaN , the result is the string \" \" . Otherwise , the result is a string that represents the sign and magnitude ( absolute value ) of the argument . If the sign is negative , the first character of the result is ' ' ( ) ; if the sign is positive , no sign character appears in the result . As for the magnitude m : If m is infinity , it is represented by the characters ; thus , positive infinity produces the result and negative infinity produces the result . If m is zero , it is represented by the characters ; thus , negative zero produces the result and positive zero produces the result . If m is greater than or equal to 10 - 3 but less than 10 7 , then it is represented as the integer part of m , in decimal form with no leading zeroes , followed by ' ' ( ) , followed by one or more decimal digits representing the fractional part of m . If m is less than 10 - 3 or greater than or equal to 10 7 , then it is represented in so - called \" computerized scientific notation . \" Let n be the unique integer such that 10 n ≤ m < 10 n + 1 ; then let a be the mathematically exact quotient of m and 10 n so that 1 ≤ a < 10 . The magnitude is then represented as the integer part of a , as a single decimal digit , followed by ' ' ( ) , followed by decimal digits representing the fractional part of a , followed by the letter ' ' ( ) , followed by a representation of n as a decimal integer , as produced by the method . How many digits must be printed for the fractional part of m or a ? There must be at least one digit to represent the fractional part , and beyond that as many , but only as many , more digits as are needed to uniquely distinguish the argument value from adjacent values of type . That is , suppose that x is the exact mathematical value represented by the decimal representation produced by this method for a finite nonzero argument d . Then d must be the value nearest to x ; or if two values are equally close to x , then d must be one of them and the least significant bit of the significand of d must be . To create localized string representations of a floating - point value , use subclasses of . Returns a hexadecimal string representation of the argument . All characters mentioned below are ASCII characters . If the argument is NaN , the result is the string \" \" . Otherwise , the result is a string that represents the sign and magnitude of the argument . If the sign is negative , the first character of the result is ' ' ( ) ; if the sign is positive , no sign character appears in the result . As for the magnitude m : If m is infinity , it is represented by the string ; thus , positive infinity produces the result and negative infinity produces the result . If m is zero , it is represented by the string ; thus , negative zero produces the result and positive zero produces the result . If m is a value with a normalized representation , substrings are used to represent the significand and exponent fields . The significand is represented by the characters followed by a lowercase hexadecimal representation of the rest of the significand as a fraction . Trailing zeros in the hexadecimal representation are removed unless all the digits are zero , in which case a single zero is used . Next , the exponent is represented by followed by a decimal string of the unbiased exponent as if produced by a call to on the exponent value . If m is a value with a subnormal representation , the significand is represented by the characters followed by a hexadecimal representation of the rest of the significand as a fraction . Trailing zeros in the hexadecimal representation are removed . Next , the exponent is represented by . Note that there must be at least one nonzero digit in a subnormal significand . Examples Floating - point Value Hexadecimal String Returns a object holding the value represented by the argument string . If is , then a is thrown . Leading and trailing whitespace characters in are ignored . Whitespace is removed as if by the method ; that is , both ASCII space and control characters are removed . The rest of should constitute a FloatValue as described by the lexical syntax rules : FloatValue : Sign opt Sign opt Sign opt FloatingPointLiteral Sign opt HexFloatingPointLiteral SignedInteger HexFloatingPointLiteral : HexSignificand BinaryExponent FloatTypeSuffix opt HexSignificand : HexNumeral HexNumeral HexDigits opt HexDigits HexDigits opt HexDigits BinaryExponent : BinaryExponentIndicator SignedInteger BinaryExponentIndicator : where Sign , FloatingPointLiteral , HexNumeral , HexDigits , SignedInteger and FloatTypeSuffix are as defined in the lexical structure sections of The Java™ Language Specification , except that underscores are not accepted between digits . If does not have the form of a FloatValue , then a is thrown . Otherwise , is regarded as representing an exact decimal value in the usual \" computerized scientific notation \" or as an exact hexadecimal value ; this exact numerical value is then conceptually converted to an \" infinitely precise \" binary value that is then rounded to type by the usual round - to - nearest rule of IEEE 754 floating - point arithmetic , which includes preserving the sign of a zero value . Note that the round - to - nearest rule also implies overflow and underflow behaviour ; if the exact value of is large enough in magnitude ( greater than or equal to ( + / 2 ) , rounding to will result in an infinity and if the exact value of is small enough in magnitude ( less than or equal to / 2 ) , rounding to float will result in a zero . Finally , after rounding a object representing this value is returned . To interpret localized string representations of a floating - point value , use subclasses of . Note that trailing format specifiers , specifiers that determine the type of a floating - point literal ( is a value ; is a value ) , do not influence the results of this method . In other words , the numerical value of the input string is converted directly to the target floating - point type . The two - step sequence of conversions , string to followed by to , is not equivalent to converting a string directly to . For example , the literal is equal to the value ; the literal represents a different numerical value than the literal . ( The numerical value 0 . 1 can not be exactly represented in a binary floating - point number . ) To avoid calling this method on an invalid string and having a be thrown , the regular expression below can be used to screen the input string : Returns a instance representing the specified value . If a new instance is not required , this method should generally be used in preference to the constructor , as this method is likely to yield significantly better space and time performance by caching frequently requested values . Returns a new initialized to the value represented by the specified , as performed by the method of class . Returns if the specified number is a Not - a - Number ( NaN ) value , otherwise . Returns if the specified number is infinitely large in magnitude , otherwise . Returns if the argument is a finite floating - point value ; returns otherwise ( for NaN and infinity arguments ) . Returns if this value is a Not - a - Number ( NaN ) , otherwise . Returns if this value is infinitely large in magnitude , otherwise . Returns a string representation of this object . The primitive value represented by this object is converted to a string exactly as if by the method of one argument . Returns the value of this as a after a narrowing primitive conversion . Returns the value of this as a after a narrowing primitive conversion . Returns the value of this as an after a narrowing primitive conversion . Returns the value of this as a after a narrowing primitive conversion . Returns the value of this as a after a narrowing primitive conversion . Returns the value of this object . Returns a hash code for this object . The result is the exclusive OR of the two halves of the integer bit representation , exactly as produced by the method , of the primitive value represented by this object . That is , the hash code is the value of the expression : where is defined by : Returns a hash code for a value ; compatible with . Compares this object against the specified object . The result is if and only if the argument is not and is a object that represents a that has the same value as the represented by this object . For this purpose , two values are considered to be the same if and only if the method returns the identical value when applied to each . Note that in most cases , for two instances of class , and , the value of is if and only if also has the value . However , there are two exceptions : If and both represent , then the method returns , even though has the value . If represents while represents , or vice versa , the test has the value , even though has the value . This definition allows hash tables to operate properly . Returns a representation of the specified floating - point value according to the IEEE 754 floating - point \" double format \" bit layout . Bit 63 ( the bit that is selected by the mask ) represents the sign of the floating - point number . Bits 62 - 52 ( the bits that are selected by the mask ) represent the exponent . Bits 51 - 0 ( the bits that are selected by the mask ) represent the significand ( sometimes called the mantissa ) of the floating - point number . If the argument is positive infinity , the result is . If the argument is negative infinity , the result is . If the argument is NaN , the result is . In all cases , the result is a integer that , when given to the method , will produce a floating - point value the same as the argument to ( except all NaN values are collapsed to a single \" canonical \" NaN value ) . Returns a representation of the specified floating - point value according to the IEEE 754 floating - point \" double format \" bit layout , preserving Not - a - Number ( NaN ) values . Bit 63 ( the bit that is selected by the mask ) represents the sign of the floating - point number . Bits 62 - 52 ( the bits that are selected by the mask ) represent the exponent . Bits 51 - 0 ( the bits that are selected by the mask ) represent the significand ( sometimes called the mantissa ) of the floating - point number . If the argument is positive infinity , the result is . If the argument is negative infinity , the result is . If the argument is NaN , the result is the integer representing the actual NaN value . Unlike the method , does not collapse all the bit patterns encoding a NaN to a single \" canonical \" NaN value . In all cases , the result is a integer that , when given to the method , will produce a floating - point value the same as the argument to . Returns the value corresponding to a given bit representation . The argument is considered to be a representation of a floating - point value according to the IEEE 754 floating - point \" double format \" bit layout . If the argument is , the result is positive infinity . If the argument is , the result is negative infinity . If the argument is any value in the range through or in the range through , the result is a NaN . No IEEE 754 floating - point operation provided by Java can distinguish between two NaN values of the same type with different bit patterns . Distinct values of NaN are only distinguishable by use of the method . In all other cases , let s , e , and m be three values that can be computed from the argument : Then the floating - point result equals the value of the mathematical expression s · m ·2 e - 1075 . Note that this method may not be able to return a NaN with exactly same bit pattern as the argument . IEEE 754 distinguishes between two kinds of NaNs , quiet NaNs and signaling NaNs . The differences between the two kinds of NaN are generally not visible in Java . Arithmetic operations on signaling NaNs turn them into quiet NaNs with a different , but often similar , bit pattern . However , on some processors merely copying a signaling NaN also performs that conversion . In particular , copying a signaling NaN to return it to the calling method may perform this conversion . So may not be able to return a with a signaling NaN bit pattern . Consequently , for some values , may not equal . Moreover , which particular bit patterns represent signaling NaNs is platform dependent ; although all NaN bit patterns , quiet or signaling , must be in the NaN range identified above . Compares two objects numerically . There are two ways in which comparisons performed by this method differ from those performed by the Java language numerical comparison operators ( ) when applied to primitive values : is considered by this method to be equal to itself and greater than all other values ( including ) . is considered by this method to be greater than . This ensures that the natural ordering of objects imposed by this method is consistent with equals . Compares the two specified values . The sign of the integer value returned is the same as that of the integer that would be returned by the call : Adds two values together as per the + operator . Returns the greater of two values as if by calling . Returns the smaller of two values as if by calling . ";

	private static final Properties POS_PROPERTIES;
	static {
		POS_PROPERTIES = new Properties();
		POS_PROPERTIES.put("annotators", "tokenize, ssplit");
	}

	public static void main(String[] args) {
		String output = Tokenizer.Tokenize(TEST_STRING);

		CoreDocument sentenceDocument = new CoreDocument(TEST_STRING);
		StanfordCoreNLP pipeline = new StanfordCoreNLP(POS_PROPERTIES);
		pipeline.annotate(sentenceDocument);

		var resultList = sentenceDocument.sentences().stream().map(CoreSentence::tokensAsStrings)
				.flatMap(Collection::stream)
				.collect(Collectors.toList());
		var joined = String.join(" ", resultList);
		output = output.replaceAll("\n", "");

		//System.out.println(output);
		//System.out.println(joined);

		System.out.println(joined.equals(output));
		System.out.println(joined.length() + " " + output.length());
//
//		for (int i = 0; i < joined.length(); i++) {
//			if (joined.charAt(i) != output.charAt(i)) {
//				System.out.println(i + " '" + joined.charAt(i) + "' '" + output.charAt(i) + "'");
//			}
//		}

		var split1 = output.replaceAll("\n", "").split(" "); // Ours
		var split2 = joined.replaceAll("\n", "").split(" "); // Theirs

		System.out.println(split1.length + " " + split2.length);

		for (int i = 0; i < split1.length; i++) {
			if (!split1[i].equals(split2[i])) {
				System.out.println("\"" + split1[i - 1] + "\" \"" + split2[i - 1] +"\"");
				System.out.println("\"" + split1[i] + "\" \"" + split2[i] +"\"");
				System.out.println("\"" + split1[i + 1] + "\" \"" + split2[i + 1] +"\"");
			}
		}
	}
}
