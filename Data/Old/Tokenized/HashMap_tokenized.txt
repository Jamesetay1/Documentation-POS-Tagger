HashMap ( Java Platform SE 8 ) 
JavaScript is disabled on your browser . 
Skip navigation links 
Overview Package Class Use Tree Deprecated Index Help 
Java™ PlatformStandard Ed . 8 
Prev Class Next Class 
Frames No Frames 
All Classes 
Summary : Nested | Field | Constr | Method 
Detail : Field | Constr | Method 
compact1 , compact2 , compact3 java . util Class HashMap < K , V > 
java . lang . 
Object 
java . util . 
AbstractMap < K , V > 
java . util . 
HashMap < K , V > 
Type Parameters : <code> K </code> - the type of keys maintained by this map <code> V </code> - the type of mapped values 
All Implemented Interfaces : Serializable , Cloneable , Map < K , V > 
Direct Known Subclasses : LinkedHashMap , PrinterStateReasons 
<pre> public class HashMap < K , V > extends AbstractMap < K , V > implements Map < K , V > , Cloneable , Serializable </pre> Hash table based implementation of the Map interface . 
This implementation provides all of the optional map operations , and permits null values and the null key . ( The HashMap class is roughly equivalent to Hashtable , except that it is unsynchronized and permits nulls . ) This class makes no guarantees as to the order of the map ; in particular , it does not guarantee that the order will remain constant over time . 
<p> This implementation provides constant - time performance for the basic operations ( get and put ) , assuming the hash function disperses the elements properly among the buckets . 
Iteration over collection views requires time proportional to the " capacity " of the HashMap instance ( the number of buckets ) plus its size ( the number of key - value mappings ) . 
Thus , it ' s very important not to set the initial capacity too high ( or the load factor too low ) if iteration performance is important . 
<p> An instance of HashMap has two parameters that affect its performance : initial capacity and load factor . 
The capacity is the number of buckets in the hash table , and the initial capacity is simply the capacity at the time the hash table is created . 
The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased . 
When the number of entries in the hash table exceeds the product of the load factor and the current capacity , the hash table is rehashed ( that is , internal data structures are rebuilt ) so that the hash table has approximately twice the number of buckets . 
<p> As a general rule , the default load factor ( . 75 ) offers a good tradeoff between time and space costs . 
Higher values decrease the space overhead but increase the lookup cost ( reflected in most of the operations of the HashMap class , including get and put ) . 
The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity , so as to minimize the number of rehash operations . 
If the initial capacity is greater than the maximum number of entries divided by the load factor , no rehash operations will ever occur . 
<p> If many mappings are to be stored in a HashMap instance , creating it with a sufficiently large capacity will allow the mappings to be stored more efficiently than letting it perform automatic rehashing as needed to grow the table . 
Note that using many keys with the same <code> hashCode ( ) </code> is a sure way to slow down performance of any hash table . 
To ameliorate impact , when keys are <code> Comparable </code> , this class may use comparison order among keys to help break ties . 
<p> Note that this implementation is not synchronized . If multiple threads access a hash map concurrently , and at least one of the threads modifies the map structurally , it must be synchronized externally . ( A structural modification is any operation that adds or deletes one or more mappings ; merely changing the value associated with a key that an instance already contains is not a structural modification . ) This is typically accomplished by synchronizing on some object that naturally encapsulates the map . 
If no such object exists , the map should be " wrapped " using the <code> Collections . synchronizedMap </code> method . 
This is best done at creation time , to prevent accidental unsynchronized access to the map : <pre> Map m = Collections . synchronizedMap ( new HashMap ( . . . ) ) ; </pre> 
<p> The iterators returned by all of this class ' s " collection view methods " are fail - fast : if the map is structurally modified at any time after the iterator is created , in any way except through the iterator ' s own remove method , the iterator will throw a <code> ConcurrentModificationException </code> . 
Thus , in the face of concurrent modification , the iterator fails quickly and cleanly , rather than risking arbitrary , non - deterministic behavior at an undetermined time in the future . 
<p> Note that the fail - fast behavior of an iterator cannot be guaranteed as it is , generally speaking , impossible to make any hard guarantees in the presence of unsynchronized concurrent modification . 
Fail - fast iterators throw ConcurrentModificationException on a best - effort basis . Therefore , it would be wrong to write a program that depended on this exception for its correctness : the fail - fast behavior of iterators should be used only to detect bugs . 
<p> This class is a member of the 
Java Collections Framework . 
Since : 1 . 2 See Also : <code> Object . hashCode ( ) </code> , <code> Collection </code> , <code> Map </code> , <code> TreeMap </code> , <code> Hashtable </code> , Serialized Form 
Nested Class Summary 
Nested classes / interfaces inherited from class java . util . 
AbstractMap <code> AbstractMap . SimpleEntry < K , V > , AbstractMap . SimpleImmutableEntry < K , V > </code> 
Nested classes / interfaces inherited from interface java . util . 
Map <code> Map . Entry < K , V > </code> 
Constructor Summary 
Constructors 
Constructor and Description 
<code> HashMap ( ) </code> Constructs an empty HashMap with the default initial capacity ( 16 ) and the default load factor ( 0 . 75 ) . 
<code> HashMap ( int initialCapacity ) </code> Constructs an empty HashMap with the specified initial capacity and the default load factor ( 0 . 75 ) . 
<code> HashMap ( int initialCapacity , float loadFactor ) </code> Constructs an empty HashMap with the specified initial capacity and load factor . 
<code> HashMap ( Map < ? extends K , ? extends V > m ) </code> Constructs a new HashMap with the same mappings as the specified Map . 
Method Summary 
All Methods Instance Methods Concrete Methods 
Modifier and Type Method and Description 
<code> void </code> <code> clear ( ) </code> Removes all of the mappings from this map . 
<code> Object </code> <code> clone ( ) </code> Returns a shallow copy of this HashMap instance : the keys and values themselves are not cloned . 
<code> V </code> <code> compute ( K key , BiFunction < ? super K , ? super V , ? extends V > remappingFunction ) </code> Attempts to compute a mapping for the specified key and its current mapped value ( or <code> null </code> if there is no current mapping ) . 
<code> V </code> <code> computeIfAbsent ( K key , Function < ? super K , ? extends V > mappingFunction ) </code> If the specified key is not already associated with a value ( or is mapped to <code> null </code> ) , attempts to compute its value using the given mapping function and enters it into this map unless <code> null </code> . 
<code> V </code> <code> computeIfPresent ( K key , BiFunction < ? super K , ? super V , ? extends V > remappingFunction ) </code> If the value for the specified key is present and non - null , attempts to compute a new mapping given the key and its current mapped value . 
<code> boolean </code> <code> containsKey ( Object key ) </code> Returns true if this map contains a mapping for the specified key . 
<code> boolean </code> <code> containsValue ( Object value ) </code> Returns true if this map maps one or more keys to the specified value . 
<code> Set < Map . Entry < K , V > > </code> <code> entrySet ( ) </code> Returns a <code> Set </code> view of the mappings contained in this map . 
<code> void </code> <code> forEach ( BiConsumer < ? super K , ? super V > action ) </code> Performs the given action for each entry in this map until all entries have been processed or the action throws an exception . 
<code> V </code> <code> get ( Object key ) </code> Returns the value to which the specified key is mapped , or <code> null </code> if this map contains no mapping for the key . 
<code> V </code> <code> getOrDefault ( Object key , V defaultValue ) </code> Returns the value to which the specified key is mapped , or <code> defaultValue </code> if this map contains no mapping for the key . 
<code> boolean </code> <code> isEmpty ( ) </code> Returns true if this map contains no key - value mappings . 
<code> Set <code> keySet ( ) </code> Returns a <code> Set </code> view of the keys contained in this map . 
<code> V </code> <code> merge ( K key , V value , BiFunction < ? super V , ? super V , ? extends V > remappingFunction ) </code> If the specified key is not already associated with a value or is associated with null , associates it with the given non - null value . 
<code> V </code> <code> put ( K key , V value ) </code> Associates the specified value with the specified key in this map . 
<code> void </code> <code> putAll ( Map < ? extends K , ? extends V > m ) </code> Copies all of the mappings from the specified map to this map . 
<code> V </code> <code> putIfAbsent ( K key , V value ) </code> If the specified key is not already associated with a value ( or is mapped to <code> null </code> ) associates it with the given value and returns <code> null </code> , else returns the current value . 
<code> V </code> <code> remove ( Object key ) </code> Removes the mapping for the specified key from this map if present . 
<code> boolean </code> <code> remove ( Object key , Object value ) </code> Removes the entry for the specified key only if it is currently mapped to the specified value . 
<code> V </code> <code> replace ( K key , V value ) </code> Replaces the entry for the specified key only if it is currently mapped to some value . 
<code> boolean </code> <code> replace ( K key , V oldValue , V newValue ) </code> Replaces the entry for the specified key only if currently mapped to the specified value . 
<code> void </code> <code> replaceAll ( BiFunction < ? super K , ? super V , ? extends V > function ) </code> Replaces each entry ' s value with the result of invoking the given function on that entry until all entries have been processed or the function throws an exception . 
<code> int </code> <code> size ( ) </code> Returns the number of key - value mappings in this map . 
<code> Collection <code> values ( ) </code> Returns a <code> Collection </code> view of the values contained in this map . 
Methods inherited from class java . util . 
AbstractMap <code> equals , hashCode , toString </code> 
Methods inherited from class java . lang . 
Object <code> finalize , getClass , notify , notifyAll , wait , wait , wait </code> 
Methods inherited from interface java . util . 
Map <code> equals , hashCode </code> 
Constructor Detail 
HashMap <pre> public HashMap ( int initialCapacity , float loadFactor ) </pre> Constructs an empty HashMap with the specified initial capacity and load factor . 
Parameters : <code> initialCapacity </code> - the initial capacity <code> loadFactor </code> - the load factor Throws : <code> IllegalArgumentException </code> - if the initial capacity is negative or the load factor is nonpositive 
HashMap <pre> public HashMap ( int initialCapacity ) </pre> Constructs an empty HashMap with the specified initial capacity and the default load factor ( 0 . 75 ) . 
Parameters : <code> initialCapacity </code> - the initial capacity . Throws : <code> IllegalArgumentException </code> - if the initial capacity is negative . 
HashMap <pre> public HashMap ( ) </pre> Constructs an empty HashMap with the default initial capacity ( 16 ) and the default load factor ( 0 . 75 ) . 
HashMap <pre> public HashMap ( Map < ? extends K , ? extends V > m ) </pre> Constructs a new HashMap with the same mappings as the specified Map . 
The HashMap is created with default load factor ( 0 . 75 ) and an initial capacity sufficient to hold the mappings in the specified Map . 
Parameters : <code> m </code> - the map whose mappings are to be placed in this map Throws : <code> NullPointerException </code> - if the specified map is null 
Method Detail 
size <pre> public int size ( ) </pre> Returns the number of key - value mappings in this map . 
Specified by : <code> size </code> in interface <code> Map < K , V > </code> Overrides : <code> size </code> in class <code> AbstractMap < K , V > </code> Returns : the number of key - value mappings in this map 
isEmpty <pre> public boolean isEmpty ( ) </pre> Returns true if this map contains no key - value mappings . 
Specified by : <code> isEmpty </code> in interface <code> Map < K , V > </code> Overrides : <code> isEmpty </code> in class <code> AbstractMap < K , V > </code> Returns : true if this map contains no key - value mappings 
get <pre> public V get ( Object key ) </pre> Returns the value to which the specified key is mapped , or <code> null </code> if this map contains no mapping for the key . 
<p> More formally , if this map contains a mapping from a key <code> k </code> to a value <code> v </code> such that <code> ( key = = null ? k = = null : key . equals ( k ) ) </code> , then this method returns <code> v </code> ; otherwise it returns <code> null </code> . ( There can be at most one such mapping . ) 
<p> A return value of <code> null </code> does not necessarily indicate that the map contains no mapping for the key ; it ' s also possible that the map explicitly maps the key to <code> null </code> . The <code> containsKey </code> operation may be used to distinguish these two cases . 
Specified by : <code> get </code> in interface <code> Map < K , V > </code> Overrides : <code> get </code> in class <code> AbstractMap < K , V > </code> Parameters : <code> key </code> - the key whose associated value is to be returned Returns : the value to which the specified key is mapped , or <code> null </code> if this map contains no mapping for the key See Also : <code> put ( Object , Object ) </code> 
containsKey <pre> public boolean containsKey ( Object key ) </pre> Returns true if this map contains a mapping for the specified key . 
Specified by : <code> containsKey </code> in interface <code> Map < K , V > </code> Overrides : <code> containsKey </code> in class <code> AbstractMap < K , V > </code> Parameters : <code> key </code> - The key whose presence in this map is to be tested Returns : true if this map contains a mapping for the specified key . 
put <pre> public V put ( K key , V value ) </pre> Associates the specified value with the specified key in this map . If the map previously contained a mapping for the key , the old value is replaced . 
Specified by : <code> put </code> in interface <code> Map < K , V > </code> Overrides : <code> put </code> in class <code> AbstractMap < K , V > </code> Parameters : <code> key </code> - key with which the specified value is to be associated <code> value </code> - value to be associated with the specified key Returns : the previous value associated with key , or null if there was no mapping for key . ( A null return can also indicate that the map previously associated null with key . ) 
putAll <pre> public void putAll ( Map < ? extends K , ? extends V > m ) </pre> Copies all of the mappings from the specified map to this map . These mappings will replace any mappings that this map had for any of the keys currently in the specified map . 
Specified by : <code> putAll </code> in interface <code> Map < K , V > </code> Overrides : <code> putAll </code> in class <code> AbstractMap < K , V > </code> Parameters : <code> m </code> - mappings to be stored in this map Throws : <code> NullPointerException </code> - if the specified map is null 
remove <pre> public V remove ( Object key ) </pre> Removes the mapping for the specified key from this map if present . 
Specified by : <code> remove </code> in interface <code> Map < K , V > </code> Overrides : <code> remove </code> in class <code> AbstractMap < K , V > </code> Parameters : <code> key </code> - key whose mapping is to be removed from the map Returns : the previous value associated with key , or null if there was no mapping for key . ( A null return can also indicate that the map previously associated null with key . ) 
clear <pre> public void clear ( ) </pre> Removes all of the mappings from this map . The map will be empty after this call returns . 
Specified by : <code> clear </code> in interface <code> Map < K , V > </code> Overrides : <code> clear </code> in class <code> AbstractMap < K , V > </code> 
containsValue <pre> public boolean containsValue ( Object value ) </pre> Returns true if this map maps one or more keys to the specified value . 
Specified by : <code> containsValue </code> in interface <code> Map < K , V > </code> Overrides : <code> containsValue </code> in class <code> AbstractMap < K , V > </code> Parameters : <code> value </code> - value whose presence in this map is to be tested Returns : true if this map maps one or more keys to the specified value 
keySet <pre> public Set <K> keySet ( ) </pre> Returns a <code> Set </code> view of the keys contained in this map . The set is backed by the map , so changes to the map are reflected in the set , and vice - versa . 
If the map is modified while an iteration over the set is in progress ( except through the iterator ' s own remove operation ) , the results of the iteration are undefined . 
The set supports element removal , which removes the corresponding mapping from the map , via the Iterator . remove , Set . remove , removeAll , retainAll , and clear operations . 
It does not support the add or addAll operations . 
Specified by : <code> keySet </code> in interface <code> Map < K , V > </code> Overrides : <code> keySet </code> in class <code> AbstractMap < K , V > </code> Returns : a set view of the keys contained in this map 
values <pre> public Collection <V> values ( ) </pre> Returns a <code> Collection </code> view of the values contained in this map . The collection is backed by the map , so changes to the map are reflected in the collection , and vice - versa . 
If the map is modified while an iteration over the collection is in progress ( except through the iterator ' s own remove operation ) , the results of the iteration are undefined . 
The collection supports element removal , which removes the corresponding mapping from the map , via the Iterator . remove , Collection . remove , removeAll , retainAll and clear operations . 
It does not support the add or addAll operations . 
Specified by : <code> values </code> in interface <code> Map < K , V > </code> Overrides : <code> values </code> in class <code> AbstractMap < K , V > </code> Returns : a view of the values contained in this map 
entrySet <pre> public Set < Map . 
Entry < K , V > > entrySet ( ) </pre> Returns a <code> Set </code> view of the mappings contained in this map . The set is backed by the map , so changes to the map are reflected in the set , and vice - versa . 
If the map is modified while an iteration over the set is in progress ( except through the iterator ' s own remove operation , or through the setValue operation on a map entry returned by the iterator ) the results of the iteration are undefined . 
The set supports element removal , which removes the corresponding mapping from the map , via the Iterator . remove , Set . remove , removeAll , retainAll and clear operations . 
It does not support the add or addAll operations . 
Specified by : <code> entrySet </code> in interface <code> Map < K , V > </code> Specified by : <code> entrySet </code> in class <code> AbstractMap < K , V > </code> Returns : a set view of the mappings contained in this map 
getOrDefault <pre> public V getOrDefault ( Object key , V defaultValue ) </pre> Description copied from interface : <code> Map </code> Returns the value to which the specified key is mapped , or <code> defaultValue </code> if this map contains no mapping for the key . 
Specified by : <code> getOrDefault </code> in interface <code> Map < K , V > </code> Parameters : <code> key </code> - the key whose associated value is to be returned <code> defaultValue </code> - the default mapping of the key Returns : the value to which the specified key is mapped , or <code> defaultValue </code> if this map contains no mapping for the key 
putIfAbsent <pre> public V putIfAbsent ( K key , V value ) </pre> Description copied from interface : <code> Map </code> If the specified key is not already associated with a value ( or is mapped to <code> null </code> ) associates it with the given value and returns <code> null </code> , else returns the current value . 
Specified by : <code> putIfAbsent </code> in interface <code> Map < K , V > </code> Parameters : <code> key </code> - key with which the specified value is to be associated <code> value </code> - value to be associated with the specified key Returns : the previous value associated with the specified key , or <code> null </code> if there was no mapping for the key . ( A <code> null </code> return can also indicate that the map previously associated <code> null </code> with the key , if the implementation supports null values . ) 
remove <pre> public boolean remove ( Object key , Object value ) </pre> Description copied from interface : <code> Map </code> Removes the entry for the specified key only if it is currently mapped to the specified value . 
Specified by : <code> remove </code> in interface <code> Map < K , V > </code> Parameters : <code> key </code> - key with which the specified value is associated <code> value </code> - value expected to be associated with the specified key Returns : <code> true </code> if the value was removed 
replace <pre> public boolean replace ( K key , V oldValue , V newValue ) </pre> Description copied from interface : <code> Map </code> Replaces the entry for the specified key only if currently mapped to the specified value . 
Specified by : <code> replace </code> in interface <code> Map < K , V > </code> Parameters : <code> key </code> - key with which the specified value is associated <code> oldValue </code> - value expected to be associated with the specified key <code> newValue </code> - value to be associated with the specified key Returns : <code> true </code> if the value was replaced 
replace <pre> public V replace ( K key , V value ) </pre> Description copied from interface : <code> Map </code> Replaces the entry for the specified key only if it is currently mapped to some value . 
Specified by : <code> replace </code> in interface <code> Map < K , V > </code> Parameters : <code> key </code> - key with which the specified value is associated <code> value </code> - value to be associated with the specified key Returns : the previous value associated with the specified key , or <code> null </code> if there was no mapping for the key . ( A <code> null </code> return can also indicate that the map previously associated <code> null </code> with the key , if the implementation supports null values . ) 
computeIfAbsent <pre> public V computeIfAbsent ( K key , Function < ? super K , ? extends V > mappingFunction ) </pre> Description copied from interface : <code> Map </code> If the specified key is not already associated with a value ( or is mapped to <code> null </code> ) , attempts to compute its value using the given mapping function and enters it into this map unless <code> null </code> . 
<p> If the function returns <code> null </code> no mapping is recorded . 
If the function itself throws an ( unchecked ) exception , the exception is rethrown , and no mapping is recorded . 
The most common usage is to construct a new object serving as an initial mapped value or memoized result , as in : 
<pre> <code> map . computeIfAbsent ( key , k - > new Value ( f ( k ) ) ) ; 
<p> Or to implement a multi - value map , <code> Map < K , Collection <V> > </code> , supporting multiple values per key : 
<pre> <code> map . computeIfAbsent ( key , k - > new HashSet <V> ( ) ) . add ( v ) ; 
Specified by : <code> computeIfAbsent </code> in interface <code> Map < K , V > </code> Parameters : <code> key </code> - key with which the specified value is to be associated <code> mappingFunction </code> - the function to compute a value Returns : the current ( existing or computed ) value associated with the specified key , or null if the computed value is null 
computeIfPresent <pre> public V computeIfPresent ( K key , BiFunction < ? super K , ? super V , ? extends V > remappingFunction ) </pre> Description copied from interface : <code> Map </code> If the value for the specified key is present and non - null , attempts to compute a new mapping given the key and its current mapped value . 
<p> If the function returns <code> null </code> , the mapping is removed . 
If the function itself throws an ( unchecked ) exception , the exception is rethrown , and the current mapping is left unchanged . 
Specified by : <code> computeIfPresent </code> in interface <code> Map < K , V > </code> Parameters : <code> key </code> - key with which the specified value is to be associated <code> remappingFunction </code> - the function to compute a value Returns : the new value associated with the specified key , or null if none 
compute <pre> public V compute ( K key , BiFunction < ? super K , ? super V , ? extends V > remappingFunction ) </pre> Description copied from interface : <code> Map </code> Attempts to compute a mapping for the specified key and its current mapped value ( or <code> null </code> if there is no current mapping ) . 
For example , to either create or append a <code> String </code> msg to a value mapping : 
<pre> <code> map . compute ( key , ( k , v ) - > ( v = = null ) ? msg : v . concat ( msg ) ) ( Method <code> merge ( ) </code> is often simpler to use for such purposes . ) 
<p> If the function returns <code> null </code> , the mapping is removed ( or remains absent if initially absent ) . 
If the function itself throws an ( unchecked ) exception , the exception is rethrown , and the current mapping is left unchanged . 
Specified by : <code> compute </code> in interface <code> Map < K , V > </code> Parameters : <code> key </code> - key with which the specified value is to be associated <code> remappingFunction </code> - the function to compute a value Returns : the new value associated with the specified key , or null if none 
merge <pre> public V merge ( K key , V value , BiFunction < ? super V , ? super V , ? extends V > remappingFunction ) </pre> Description copied from interface : <code> Map </code> If the specified key is not already associated with a value or is associated with null , associates it with the given non - null value . Otherwise , replaces the associated value with the results of the given remapping function , or removes if the result is <code> null </code> . 
This method may be of use when combining multiple mapped values for a key . For example , to either create or append a <code> String msg </code> to a value mapping : 
<pre> <code> map . merge ( key , msg , String : : concat ) 
<p> If the function returns <code> null </code> the mapping is removed . 
If the function itself throws an ( unchecked ) exception , the exception is rethrown , and the current mapping is left unchanged . 
Specified by : <code> merge </code> in interface <code> Map < K , V > </code> Parameters : <code> key </code> - key with which the resulting value is to be associated <code> value </code> - the non - null value to be merged with the existing value associated with the key or , if no existing value or a null value is associated with the key , to be associated with the key <code> remappingFunction </code> - the function to recompute a value if present Returns : the new value associated with the specified key , or null if no value is associated with the key 
forEach <pre> public void forEach ( BiConsumer < ? super K , ? super V > action ) </pre> Description copied from interface : <code> Map </code> Performs the given action for each entry in this map until all entries have been processed or the action throws an exception . 
Unless otherwise specified by the implementing class , actions are performed in the order of entry set iteration ( if an iteration order is specified . ) Exceptions thrown by the action are relayed to the caller . 
Specified by : <code> forEach </code> in interface <code> Map < K , V > </code> Parameters : <code> action </code> - The action to be performed for each entry 
replaceAll <pre> public void replaceAll ( BiFunction < ? super K , ? super V , ? extends V > function ) </pre> Description copied from interface : <code> Map </code> Replaces each entry ' s value with the result of invoking the given function on that entry until all entries have been processed or the function throws an exception . 
Exceptions thrown by the function are relayed to the caller . 
Specified by : <code> replaceAll </code> in interface <code> Map < K , V > </code> Parameters : <code> function </code> - the function to apply to each entry 
clone <pre> public Object clone ( ) </pre> Returns a shallow copy of this HashMap instance : the keys and values themselves are not cloned . 
Overrides : <code> clone </code> in class <code> AbstractMap < K , V > </code> Returns : a shallow copy of this map See Also : <code> Cloneable </code> 
Skip navigation links 
Overview Package Class Use Tree Deprecated Index Help 
Java™ PlatformStandard Ed . 8 
Prev Class Next Class 
Frames No Frames 
All Classes 
Summary : Nested | Field | Constr | Method 
Detail : Field | Constr | Method 
Submit a bug or feature For further API reference and developer documentation , see Java SE Documentation . 
That documentation contains more detailed , developer - targeted descriptions , with conceptual overviews , definitions of terms , workarounds , and working code examples . 
Copyright © 1993 , 2020 , Oracle and / or its affiliates . 
All rights reserved . 
Use is subject to license terms . 
Also see the documentation redistribution policy . 